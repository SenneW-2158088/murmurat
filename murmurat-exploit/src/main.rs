use bytes::Bytes;
use murmurat_core::coding::Decode;
use murmurat_core::message::MurmuratMessage;
use pcap_parser::traits::{PcapNGPacketBlock, PcapReaderIterator};
use pcap_parser::*;
use std::fs::File;

fn main() -> std::io::Result<()> {
    let filepath = "/Users/zenneh/Downloads/aac-r-ts-capture-fbropt.pcapng";
    println!("Opened file");
    let file = File::open(filepath)?;
    let mut reader =
        PcapNGReader::new(1024 * 1024 * 500, file).expect("Failed to create PcapNGReader");
    println!("Created reader");

    while let Ok((size, block)) = reader.next() {
        match block {
            PcapBlockOwned::NG(Block::EnhancedPacket(packet)) => {
                println!("block");
                if let Some(murmurat) = process_packet(&packet) {
                    println!("MURRR: {:?}", murmurat);
                }
            }
            _ => {}
        }

        reader.consume(size);
    }
    Ok(())
}

fn process_packet(epb: &EnhancedPacketBlock) -> Option<MurmuratMessage> {
    let packet_data = epb.packet_data();

    if packet_data.len() <= 14 {
        return None;
    }
    let data = &packet_data[14..];
    println!("parsed the ether");

    // Get IP header length
    if data.len() < 1 {
        return None;
    }

    let ip_header_len = ((data[0] & 0x0F) * 4) as usize;
    println!("parsed the ip");

    // Skip to UDP payload
    if data.len() <= ip_header_len + 8 {
        return None;
    }
    let udp_payload = &data[ip_header_len + 8..];
    println!("parsed the udp");

    // Try to decode
    if !udp_payload.is_empty() {
        let mut buffer = Bytes::copy_from_slice(udp_payload);
        if let Ok(msg) = MurmuratMessage::decode(&mut buffer) {
            return Some(msg);
        } else {
            eprintln!("Failed to decode");
        }
    }

    None
}

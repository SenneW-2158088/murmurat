use bytes::Bytes;
use chrono::{Datelike, TimeZone, Utc};
use murmurat_core::coding::Decode;
use murmurat_core::message::MurmuratMessage;
use murmurat_core::{VERSE_OF_ACKNOWLEDGEMENTS, VERSE_OF_ACKNOWLEDGEMENTS_2};
use pcap_parser::traits::{PcapNGPacketBlock, PcapReaderIterator};
use pcap_parser::*;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

fn process_packets(filename: &str, buffer: &mut Vec<MurmuratMessage>) -> std::io::Result<()> {
    let file = File::open(filename)?;
    let mut reader =
        PcapNGReader::new(1024 * 1024 * 100, file).expect("Failed to create PcapNGReader");

    while let Ok((size, block)) = reader.next() {
        match block {
            PcapBlockOwned::NG(Block::EnhancedPacket(packet)) => {
                if let Some(murmurat) = process_packet(&packet) {
                    buffer.push(murmurat);
                }
            }
            _ => {}
        }

        reader.consume(size);
    }
    Ok(())
}

fn main() -> std::io::Result<()> {
    let wolf = "/home/amadeusw/projects/murmurat/assets/aac-r-ts-capture-fbropt.pcapng";
    let zenneh = "/Users/zenneh/Downloads/aac-r-ts-capture-fbropt.pcapng";

    let mut packets = Vec::default();
    process_packets(zenneh, &mut packets)?;

    let mut keystreams: HashMap<u8, Vec<u8>> = HashMap::new();
    process_keystreams(&mut packets, &mut keystreams);
    println!("[+] Found {} keystreams", keystreams.len());

    let mut decrypted = Vec::new();
    decrypt_packets(&mut packets, &mut keystreams, &mut decrypted);

    write_to_file("output.txt", &mut decrypted)?;

    Ok(())
}

fn write_to_file(filename: &str, decrypted: &mut Vec<String>) -> std::io::Result<()> {
    let mut file = File::create(filename)?;

    for decrypt in decrypted {
        let decrypt = decrypt.clone() + "\n";
        file.write_all(decrypt.as_bytes())?;
    }

    Ok(())
}

fn decrypt_packets(
    packets: &mut Vec<MurmuratMessage>,
    keystreams: &mut HashMap<u8, Vec<u8>>,
    decrypted: &mut Vec<String>,
) {
    for packet in packets {
        if let MurmuratMessage::Data(message) = packet {
            let Some(keystream) = keystreams.get(&message.nonce) else {
                continue;
            };
            let d = decrypt_with_keystream(&message.data, keystream);
            let s = String::from_utf8_lossy(&d).into_owned();
            decrypted.push(s);
        }
    }
}

fn process_keystreams(packets: &mut Vec<MurmuratMessage>, keystreams: &mut HashMap<u8, Vec<u8>>) {
    for packet in packets {
        if let MurmuratMessage::Data(message) = packet {
            let timestamp = Utc
                .timestamp_opt(message.timestamp as i64, 0)
                .single()
                .unwrap();
            if timestamp.month() == 2 && timestamp.day() == 14 {
                // if message.data.len() - 20 >= VERSE_OF_ACKNOWLEDGEMENTS.len() {
                let known_plaintext = VERSE_OF_ACKNOWLEDGEMENTS.as_bytes();
                let keystream = derive_keystream(&message.data, &known_plaintext);

                if keystreams.contains_key(&message.nonce) {
                    // println!("Duplicate key");
                    let stored = keystreams.get(&message.nonce).unwrap();
                    // println!("Stored: {:?}", stored);
                    // println!("Current: {:?}", keystream);
                } else {
                    // Store the keystream for this nonce
                    keystreams.insert(message.nonce, keystream);
                }

                println!("Recovered keystream for nonce {}", message.nonce);
            }
            // }
        }
    }
}

fn derive_keystream(plaintext: &[u8], ciphertext: &[u8]) -> Vec<u8> {
    plaintext
        .iter()
        .zip(ciphertext.iter().cycle())
        .map(|(p, c)| p ^ c)
        .collect()
}

fn decrypt_with_keystream(ciphertext: &[u8], keystream: &[u8]) -> Vec<u8> {
    ciphertext
        .iter()
        .zip(keystream.iter().cycle()) // cycle() handles if ciphertext is longer than keystream
        .map(|(c, k)| c ^ k)
        .collect()
}

fn process_packet(epb: &EnhancedPacketBlock) -> Option<MurmuratMessage> {
    let packet_data = epb.packet_data();

    // internet, udp bla bla
    let data = &packet_data[28..];

    let mut buffer = Bytes::copy_from_slice(data);
    if let Ok(msg) = MurmuratMessage::decode(&mut buffer) {
        return Some(msg);
    } else {
        eprintln!("Failed to decode");
    }

    None
}

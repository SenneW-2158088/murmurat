use bytes::Bytes;
use murmurat_core::coding::Decode;
use murmurat_core::message::MurmuratMessage;
use pcap_parser::traits::{PcapNGPacketBlock, PcapReaderIterator};
use pcap_parser::*;
use std::fs::File;

fn main() -> std::io::Result<()> {
    let filepath = "/home/amadeusw/projects/murmurat/assets/aac-r-ts-capture-fbropt.pcapng";
    println!("Opened file");
    let file = File::open(filepath)?;
    let mut reader =
        PcapNGReader::new(1024 * 1024 * 100, file).expect("Failed to create PcapNGReader");
    println!("Created reader");

    while let Ok((size, block)) = reader.next() {
        match block {
            PcapBlockOwned::NG(Block::EnhancedPacket(packet)) => {
                if let Some(murmurat) = process_packet(&packet) {
                    println!("MURRR: {:?}", murmurat);
                }
            }
            _ => {}
        }

        if size <= reader.data().len() {
            println!("Consuming {} bytes", size);
            reader.consume(size);
        } else {
            eprintln!("Error: Size to consume is larger than remaining buffer.");
        }
    }
    Ok(())
}

fn process_packet(epb: &EnhancedPacketBlock) -> Option<MurmuratMessage> {
    let packet_data = epb.packet_data();

    println!("packet data: {:?}", packet_data.len());

    // internet, udp bla bla
    let data = &packet_data[28..];
    println!("removed first 28 bytes, remaining data: {}", data.len());

    let mut buffer = Bytes::copy_from_slice(data);
    if let Ok(msg) = MurmuratMessage::decode(&mut buffer) {
        return Some(msg);
    } else {
        eprintln!("Failed to decode");
    }

    None
}
